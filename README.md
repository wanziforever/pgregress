3 PostgreSQL automated regresstion testing tool,

it is a python implementation of postgresql offical isolation automation testing tool.
but it support more features.

# why develop this tool
normal postgresql automation only support simple sql execution, and the isolation related test need more complex scenarios
it need to execute sqls in different sessions, it can wait and detect lockings, etc.

i develop this tool base a complex solution, and it can support most of the scenarios which including the simple sql execution


# how to use it
## prepare the postgresql binary installation files
- conigure the directory of the instalation files to config.py file
- make sure you current directory has write permission

## all the test case were managed by `profile`
profile is a directory which hold the testcases in the same feature test, or a project, this is only a testcase management consibderation
there should be a schedule file in the profile directory, and the schedule file is used to manage the testcase execution sequence,
although the schedule and tool support parallel case execution, but use it only in case you can make sure your cases cannot interrupt each other.

```
the schedule file format is :
test: aborted-keyrevoke
test: alter-table-1
test: alter-table-2
test: alter-table-3
test: alter-table-4
...
```

## the testcase file format
```
setup
{
 CREATE TABLE a (i int PRIMARY KEY);
 CREATE TABLE b (a_id int);
 INSERT INTO a VALUES (0), (1), (2), (3);
 INSERT INTO b SELECT generate_series(1,1000) % 4;
}

teardown
{
 DROP TABLE a, b;
}

session "s1"
step "s1"	{ BEGIN; }
step "at1"	{ ALTER TABLE b ADD CONSTRAINT bfk FOREIGN KEY (a_id) REFERENCES a (i) NOT VALID; }
step "sc1"	{ COMMIT; }
step "s2"	{ BEGIN; }
step "at2"	{ ALTER TABLE b VALIDATE CONSTRAINT bfk; }
step "sc2"	{ COMMIT; }

session "s2"
setup		{ BEGIN; }
step "rx1"	{ SELECT * FROM b WHERE a_id = 1 LIMIT 1; }
step "wx"	{ INSERT INTO b VALUES (0); }
step "rx3"	{ SELECT * FROM b WHERE a_id = 3 LIMIT 3; }
step "c2"	{ COMMIT; }

permutation "s1" "at1" "sc1" "s2" "at2" "sc2" "rx1" "wx" "rx3" "c2"
permutation "s1" "at1" "sc1" "s2" "at2" "rx1" "sc2" "wx" "rx3" "c2"
permutation "s1" "at1" "sc1" "s2" "at2" "rx1" "wx" "sc2" "rx3" "c2"
permutation "s1" "at1" "sc1" "s2" "at2" "rx1" "wx" "rx3" "sc2" "c2"
```

- setup: sqls before executing the session sqls
- teardown: sqls after executing the session sqls
- session: the sqls to test
- permutation: the permutations for session steps, if you don't provide the permutation, all the permutations of the all the steps will be generated by default (which is not recommended)


# how to run the tool
- go to the tool directory, execute the `. ./set`
- run `./main.py`

# how to see the report
the report.html file will be generated after the profile finish testing.
the html file will be under the profile outputs direcotry

# how to save the expected output files
every testcase has sql execution outputs which is used to make a comparation.
each time you run the tool, the new outputs for each case will be saved to outputs/results directory
and this new output files will do a comparation to the expected directory.
so what you need to do is put the `succeed` version output file to the expected directory before the offical test

